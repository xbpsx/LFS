В очень редких случаях необходимо использовать бинарники формата `a.out` — либо потому, что исходный код недоступен, либо потому, что по какой-то причине невозможно собрать новые `ELF`-бинарники из исходников.

Как правило, в `ELF`-системах почти всегда имеется полный набор библиотек `a.out` в каталоге `/usr/i486-linuxaout/lib`. Схема нумерации версий для библиотек `a.out` отличается от таковой для `ELF`, что разумно позволяет избежать конфликтов, которые могли бы вызвать путаницу. Таким образом, бинарники a.out должны быть в состоянии найти правильные библиотеки во время выполнения, но это не всегда так.

Обратите внимание, что **в ядре должна быть встроена поддержка a.out** — либо напрямую, либо в виде загружаемого модуля. Возможно, потребуется пересобрать ядро, чтобы включить эту поддержку. Более того, некоторые дистрибутивы Linux требуют установки специального пакета совместимости, такого как `xcompat` в Debian, для выполнения X-приложений в формате `a.out.`

## Пример

Джерри Смит несколько лет назад написал очень удобную программу-органайзер (`rolodex`). Она использует библиотеки `Motif`, но, к счастью, доступна в виде статически скомпонованного бинарника в формате `a.out`. К сожалению, для пересборки исходников с использованием библиотек `LessTif` требуются многочисленные правки. Что еще хуже, бинарник `a.out `вылетает на `ELF`-системе со следующим сообщением об ошибке:

```text
xrolodex: can't load library '//lib/libX11.so.3'
No such library
```

На самом деле такая библиотека существует — в `/usr/i486-linuxaout/lib`, но `xrolodex` не может найти ее во время выполнения. Простое решение — создать символическую ссылку в каталоге `/lib`:

```bash
ln -s /usr/i486-linuxaout/lib/X11.so.3.1.0 libX11.so.3
```

Оказывается, необходимо создать аналогичные ссылки для библиотек `libXt.so.3` и `libc.so.4`. Это, конечно, нужно делать от имени `root`. Обратите внимание: вы должны быть абсолютно уверены, что не перезапишете существующие библиотеки и не вызовете конфликты номеров версий. К счастью, новые ELF-библиотеки имеют более высокие номера версий, чем старые `a.out`, что как раз и предвосхищает и предотвращает подобные проблемы.

После создания трех ссылок `xrolodex` запускается и работает нормально.

Пакет `xrolodex` изначально был размещен на `Spectro`, но, кажется, оттуда исчез. В настоящее время его можно загрузить с Sunsite в виде исходного файла в формате `tar.Z [512k]`.

---
[[Навигация по книге «Building and Installing Software Packages for Linux»]]

### Зачем вам это нужно? Развёрнутые пояснения

Эта глава представляет собой **исторический экскурс** в эволюцию форматов исполняемых файлов в Linux. Хотя сегодня это в основном архаизм, понимание этих концепций дает глубокое представление о том, как развивалась система.

**1. Эволюция форматов исполняемых файлов: a.out → ELF**

- **a.out (Assembler Output):** Самый старый формат исполняемых файлов в UNIX. Простая структура, использовалась в ранних версиях Linux. Имел серьезные ограничения: плохая поддержка динамических библиотек, сложности с разделением кода и данных.

- **ELF (Executable and Linkable Format):** Современный, гибкий формат, принятый в середине 1990-х. Поддерживает:

    - Динамические библиотеки (shared objects, `.so`)
    
    - Позиционно-независимый код (PIC)
    
    - Отладочную информацию (DWARF)
    
    - Множество секций и сегментов

- **Для LFS:** Вся система LFS будет построена на **ELF**. Это стандарт де-факто для всех современных Linux-систем. В книге LFS нигде не упоминается a.out.

**2. Почему это важно знать?**

- **Понимание совместимости:** Автор показывает, как Linux решает проблему обратной совместимости — через отдельные каталоги с библиотеками (`/usr/i486-linuxaout/lib`) и символические ссылки.

- **Принцип работы динамического загрузчика:** Пример с `xrolodex` демонстрирует, как `ld.so` (динамический загрузчик) ищет библиотеки. По умолчанию он ищет ELF-библиотеки в стандартных путях (`/lib`, `/usr/lib`). Для `a.out` библиотек нужны дополнительные настройки.

- **Исторический контекст:** Понимание этой эволюции помогает оценить современные возможности ELF и то, почему он стал стандартом.

**3. Практическое значение для LFS:**

- **Вам не понадобится a.out:** При сборке LFS вы будете работать исключительно с ELF. Все инструменты цепочки компиляции (gcc, binutils) настроены на генерацию ELF-файлов.

- **Важный урок о динамических библиотеках:** Принцип, показанный в примере (создание символических ссылок для разрешения зависимостей), актуален и для ELF. В LFS вы будете создавать символические ссылки для библиотек, например:

```bash
ln -sv /usr/lib/libgmp.so /usr/lib/libgmp.so.3
```

- **Понимание ядерной поддержки:** Упоминание о необходимости поддержки a.out в ядре — хороший пример того, как возможности ядра влияют на пользовательское пространство. В LFS вы будете конфигурировать ядро и должны понимать значение каждой опции.

**4. Современная ситуация:**

- **Полный переход на ELF:** Все современные дистрибутивы используют исключительно ELF.

- **Устаревание a.out:** Поддержка a.out была удалена из ядра Linux несколько лет назад (примерно в 2019 году в основной ветке). Даже опции компиляции ядра для a.out больше нет.

- **Multilib вместо a.out:** Современные системы решают проблему совместимости через multilib (поддержка 32-битных библиотек на 64-битных системах), а не через a.out.

**5. Чему учит пример с xrolodex:**

1. **Анализ ошибок:** Программа сообщает, что не может найти `libX11.so.3`. Это типичная ошибка зависимости.

2. **Поиск библиотек:** Автор знает, где искать a.out библиотеки (`/usr/i486-linuxaout/lib`).

3. **Создание символических ссылок:** Решение — создать ссылки в `/lib`, чтобы динамический загрузчик мог их найти.

4. **Предостережение о версиях:** Важно не перезаписать существующие ELF-библиотеки с теми же именами.


**Практическое упражнение (на современной системе):**

1. Проверьте формат ваших исполняемых файлов:

```bash
file /bin/ls
```

Вы увидите что-то вроде: `ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked...`

2. Посмотрите, какие библиотеки требуются программе:

```bash
ldd /bin/ls
```

3. Изучите структуру ELF-файла:

```bash
readelf -h /bin/ls  # заголовки
readelf -d /bin/ls  # динамические секции
```

**Итог главы:**  
Хотя глава посвящена устаревшей технологии, она учит важным принципам:

1. **Эволюция систем:** Linux постоянно развивается, и новые технологии заменяют старые.

2. **Механизмы совместимости:** Операционные системы должны обеспечивать обратную совместимость, но это часто делается через специальные механизмы (отдельные библиотеки, символические ссылки).

3. **Понимание зависимостей:** Проблема "не найдена библиотека" и способы ее решения актуальны и сегодня, просто для ELF-формата.

**Для LFS:** Вы будете строить чистую, современную ELF-систему без груза устаревших форматов. Но понимание истории помогает ценить преимущества ELF и осознанно подходить к конфигурации системы. Знание о a.out — это часть культурного багажа Linux-системного администратора.
