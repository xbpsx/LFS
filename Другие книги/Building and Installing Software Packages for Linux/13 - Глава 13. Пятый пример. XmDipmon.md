**Булвинкль:** Эй, Рокки, смотри, как я вытащу кролика из шляпы.  
**Рокки:** Но этот трюк никогда не работает.  
**Булвинкль:** На этот раз точно получится.  
Престо!  
Ну, я уже близок.  
**Рокки:** А теперь время для очередного специального выпуска.  
— «Рокки и его друзья»

**XmDipmon** — это удобное небольшое приложение, которое отображает кнопку, показывающую статус подключения к Интернету. Она мигает и издает звуковой сигнал, когда соединение разрывается, что, к сожалению, слишком часто случается в сельских телефонных системах. К сожалению, XmDipmon работает только с `dip`, что делает его бесполезным для тех людей (а их большинство), кто использует `chat` для подключения.

Сборка XmDipmon не является проблемой. XmDipmon линкуется с библиотеками Motif, но он успешно собирается и работает с Lesstif. Задача заключается в том, чтобы изменить пакет для работы с `chat`. Это требует фактического вмешательства в исходный код и, следовательно, некоторых знаний программирования.

```text
"When xmdipmon starts up, it checks for a file called /etc/dip.pid
 (you can let it look at another file by using the -pidfile
 command line option).  This file contains the PID of the dip
 deamon (dip switches itself into deamon mode once it has
 established a connection)."
               --- из файла README XmDipmon
```

Используя опцию `-pidfile`, программу можно настроить на проверку другого файла при запуске, того, который существует только во время успешного подключения через `chat`. Очевидный кандидат — файл блокировки модема. Поэтому мы можем попробовать запустить программу с `xmdipmon -pidfile /var/lock/LCK..ttyS3` (предполагается, что модем находится на com-порту #4, ttyS3). Однако это решает только часть проблемы. Программа постоянно отслеживает демон `dip`, и нам нужно изменить это, чтобы она вместо этого опрашивала процесс, связанный с `chat` или `ppp`.

Исходный файл всего один, и, к счастью, он хорошо прокомментирован. Просматривая файл `xmdipmon.c`, мы находим функцию `getProcFile`, описание которой гласит:

```c
/*****
* Name:                 getProcFile
* Return Type:  Boolean
* Description:  tries to open the /proc entry as read from the dip pid file.
<snip>
*****/
```

Теперь мы на верном пути. Углубляемся в тело функции...

```c
                            /* we watch the status of the real dip deamon */
                            sprintf(buf, "/proc/%i/status", pid);
                            procfile = (String)XtMalloc(strlen(buf)*sizeof(char)+1);
                            strcpy(procfile, buf);
                            procfile[strlen(buf)] = '\0';
```

Причина проблем — строка 2383:

```c
                            sprintf(buf, "/proc/%i/status", pid);
                                          ^^^^^^^^^^^^^^^^^^^^^
```

Это проверяет, запущен ли процесс демона `dip`. Итак, как мы можем изменить это, чтобы отслеживать демон `pppd` вместо него?

Смотрим в man-страницу `pppd`:

```text
FILES
       /var/run/pppn.pid (BSD or Linux), /etc/ppp/pppn.pid (others)
                     Process-ID for pppd process on ppp interface unit n.
```

Меняем строку 2383 в `xmdipmon.c` на:

```c
                            sprintf(buf, "/var/run/ppp0.pid" );
```

Пересобираем измененный пакет. Со сборкой проблем нет. Теперь тестируем с новым аргументом командной строки. Работает как часы. Маленькая синяя кнопка показывает, когда установлено ppp-соединение с ISP, и мигает и пищит, когда соединение разорвано. Теперь у нас есть полностью функциональный монитор для `chat`.

XmDipmon можно загрузить с Ripley Linux Tools.

---
[[Навигация по книге «Building and Installing Software Packages for Linux»]]

### Зачем вам это нужно? Развёрнутые пояснения

Этот пример выводит вас на **уровень системного программирования**. Здесь вы не просто исправляете ошибки сборки или меняете пути к библиотекам — вы **модифицируете логику работы программы**, чтобы адаптировать ее под свои нужды. Это высшая степень контроля над программным обеспечением.

**1. Понимание задачи:**

- Исходная программа (`XmDipmon`) была написана для мониторинга соединения, установленного через утилиту `dip`.

- Автор использует `chat` и `ppp` (более современные и распространенные способы подключения к интернету в то время).

- Задача: заставить программу мониторить не `dip`, а `ppp`-соединение.

**2. Анализ исходного кода:**

- Автор находит в README ключевую информацию: программа проверяет файл `/etc/dip.pid`, в котором хранится идентификатор процесса (PID) демона `dip`.

- Используя ключ `-pidfile`, можно указать другой файл. Автор пробует использовать файл блокировки модема (`/var/lock/LCK..ttyS3`), но это решает только часть проблемы.

- **Глубокая проблема:** Программа не просто проверяет наличие файла, она отслеживает состояние процесса через `/proc/<PID>/status`. Нужно изменить эту логику.


**3. Поиск и модификация кода:**

- Автор находит функцию `getProcFile`, которая отвечает за мониторинг процесса.

- Видит, что программа строит путь к файлу статуса процесса в `/proc` на основе PID, считанного из файла.

- Решение: вместо того чтобы строить путь к статусу процесса `dip`, программа должна проверять файл PID для `ppp` (в данном случае `/var/run/ppp0.pid`).


**4. Почему это работает?**

- В Linux демоны часто записывают свой PID в файл (обычно в `/var/run/`). Это позволяет другим программам узнать, запущен ли демон, и отправить ему сигналы.

- Программа `XmDipmon` изначально читала PID из файла, затем проверяла, существует ли соответствующий процесс в `/proc`. Автор меняет логику так, чтобы программа просто проверяла существование файла PID для `ppp`. Если файл существует — соединение установлено; если нет — соединение разорвано.


**5. Риски и ограничения такого подхода:**

- **Упрощение логики:** Исходная программа отслеживала состояние процесса через `/proc/<PID>/status`. Новая версия только проверяет существование файла. Это может быть недостаточно, если файл PID остался после аварийного завершения демона.

- **Жесткое кодирование пути:** Автор жестко прописывает `/var/run/ppp0.pid`. Это негибко: что если у пользователя несколько ppp-соединений? Лучшим решением было бы сделать путь конфигурируемым.

- **Безопасность:** Изменение исходного кода требует понимания того, что делает программа. Неправильная модификация может привести к сбоям или уязвимостям.


**6. Как это связано с LFS:**

- В LFS вы не будете модифицировать исходный код пакетов (если только не возникнет специфических проблем). Но понимание того, как программы взаимодействуют с системой (через файлы PID, `/proc`, системные вызовы), критически важно.

- **Навык чтения и понимания чужого кода** — один из самых важных для системного администратора. В процессе сборки LFS вы будете читать много скриптов, Makefile-ов и, возможно, исходников.

- **Умение вносить минимальные изменения** для адаптации программы под свои нужды — это то, что отличает опытного пользователя от новичка.


**7. Современные аналоги:**

- Сегодня подобные задачи решаются с помощью более современных инструментов мониторинга сети. Но принцип остается тем же: программы часто используют файлы PID и `/proc` для взаимодействия с другими процессами.


**Практические уроки:**

1. **Чтение документации:** Всегда начинайте с README и man-страниц.

2. **Анализ кода:** Ищите ключевые функции и понимайте их назначение.

3. **Минимальные изменения:** Вносите только те изменения, которые необходимы для достижения цели.

4. **Понимание системы:** Знание о том, как Linux управляет процессами (файлы PID, `/proc`), позволяет находить элегантные решения.


**Итог всего руководства:**

Вы прошли полный путь — от распаковки архива до глубокой модификации исходного кода. Теперь вы умеете:

- Собирать программы из исходников

- Анализировать и исправлять ошибки сборки

- Адаптировать старые программы к современным системам

- Модифицировать логику программ под свои нужды


**Вы готовы к LFS.**

Сборка Linux From Scratch потребует от вас всех этих навыков, примененных в масштабе целой операционной системы. Вы будете собирать сотни пакетов, настраивать их взаимодействие, решать возникающие проблемы. Но теперь у вас есть основа — понимание того, как работает процесс сборки и установки ПО в Linux.

Помните: Linux дает вам свободу изучать, изменять и улучшать систему. Это руководство дало вам инструменты для реализации этой свободы. Используйте их с умом, и вы сможете создать систему, которая идеально соответствует вашим потребностям.

Удачи в вашем путешествии в мир Linux!
