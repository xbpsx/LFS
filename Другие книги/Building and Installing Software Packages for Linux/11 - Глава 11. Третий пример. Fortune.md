Этот пример требует некоторых знаний программирования на C. Большинство программного обеспечения UNIX/Linux написано на C, и изучение хотя бы основ C, безусловно, будет полезным для любого, кто серьезно занимается установкой программного обеспечения.

Печально известная программа `fortune` отображает юмористическое высказывание, "печенье с предсказанием", при каждой загрузке Linux. К сожалению (игра слов), попытка собрать `fortune` на дистрибутиве Red Hat с ядром 2.0.30 приводит к фатальным ошибкам.

```text
~/fortune# make all

gcc -O2 -Wall -fomit-frame-pointer -pipe   -c fortune.c -o fortune.o
fortune.c: In function `add_dir':
fortune.c:551: structure has no member named `d_namlen'
fortune.c:553: structure has no member named `d_namlen'
make[1]: *** [fortune.o] Error 1
make[1]: Leaving directory `/home/thegrendel/for/fortune/fortune'
make: *** [fortune-bin] Error 2
```

Посмотрев на `fortune.c`, соответствующие строки таковы:

```text
if (dirent->d_namlen == 0)
    continue;
name = copy(dirent->d_name, dirent->d_namlen);
```

Нам нужно найти структуру `dirent`, но она не объявлена в файле `fortune.c`, и поиск через `grep dirent` не показывает ее в других исходных файлах. Однако в начале `fortune.c` есть следующая строка:

```text
#include <dirent.h>
```

Это, по-видимому, системный заголовочный файл, поэтому логичное место для поиска `dirent.h` — `/usr/include`. Действительно, в `/usr/include` существует файл `dirent.h`, но он не содержит объявления структуры `dirent`. Однако там есть ссылка на другой файл `dirent.h`:

```text
#include <linux/dirent.h>
```

Наконец, перейдя к `/usr/include/linux/dirent.h`, мы находим нужное объявление структуры:

```text
struct dirent {
    long            d_ino;
    __kernel_off_t  d_off;
    unsigned short  d_reclen;
    char            d_name[256]; /* We must not include limits.h! */
};
```

Действительно, объявление структуры не содержит `d_namelen`, но есть пара "кандидатов" на его замену. Наиболее вероятным из них является `d_reclen`, поскольку этот член структуры, вероятно, представляет длину чего-то и является коротким целым. Другая возможность, `d_ino`, судя по имени и типу, может быть номером `inode`. На самом деле, мы, вероятно, имеем дело со структурой "запись каталога", и эти элементы представляют атрибуты файла: его имя, `inode` и длину (в блоках). Это, кажется, подтверждает наше предположение.

Давайте отредактируем файл `fortune.c` и заменим два упоминания `d_namelen` в строках 551 и 553 на `d_reclen`. Попробуем снова выполнить `make all`. Успех. Программа собирается без ошибок. Теперь мы можем получать "дешевые острые ощущения" от `fortune`.

---
[[Навигация по книге «Building and Installing Software Packages for Linux»]]


### Зачем вам это нужно? Развёрнутые пояснения

Этот пример заходит еще дальше в мир **отладки исходного кода**. Теперь речь идет не просто о настройке путей или порядке библиотек, а о необходимости **понимать и модифицировать исходный код программы** для ее сборки на вашей системе.

**1. Анализ ошибки компилятора:**

- Компилятор указывает на конкретную ошибку: в структуре `dirent` нет члена `d_namlen`. Это происходит потому, что программа была написана для другой системы или более старой версии библиотеки, где эта структура имела другой формат.

- **Для LFS:** Вы столкнетесь с подобными проблемами при сборке некоторых пакетов. В книге LFS часто указываются необходимые патчи, но понимание того, как работают эти патчи, позволит вам лучше разбираться в проблемах и, возможно, создавать свои исправления.


**2. Поиск определения структуры:**

- Автор использует системный подход: он начинает с включенного заголовочного файла (`dirent.h`) и ищет фактическое определение структуры.

- Он обнаруживает, что `/usr/include/dirent.h` включает другой файл — `/usr/include/linux/dirent.h`. Это хороший пример многоуровневой организации заголовочных файлов в Linux.

- **Важный навык:** Умение использовать `grep` для поиска в исходных кодах и понимание иерархии системных заголовочных файлов.


**3. Анализ структуры данных:**

- Автор находит определение структуры `dirent` в ядерных заголовках (`linux/dirent.h`). В ней нет `d_namlen`, но есть похожие поля.

- **Логическое рассуждение:** Автор анализирует назначение полей структуры:

    - `d_ino` — скорее всего, номер `inode` (уникальный идентификатор файла в файловой системе).
    
    - `d_reclen` — вероятно, длина записи (record length). Это наиболее вероятный кандидат для замены `d_namlen`, так как длина имени файла может быть частью длины записи.
    
    - `d_name` — имя файла.

- **Для LFS:** Умение читать и понимать системные структуры данных — это продвинутый навык, который пригодится не только для сборки программ, но и для системного программирования.


**4. Принятие решения и внесение изменений:**

- Автор решает заменить `d_namlen` на `d_reclen`. Это решение основано на логическом выводе, а не на случайном выборе.

- **Риск:** Такое изменение может сломать программу, если `d_reclen` означает что-то другое. Однако автор осознанно идет на этот риск и проверяет результат.

- **Для LFS:** При сборке LFS вы будете применять готовые патчи, которые уже протестированы сообществом. Но в своей дальнейшей практике вы можете столкнуться с ситуациями, когда нужно самостоятельно принять подобное решение.


**5. Успешная сборка:**

- После внесения изменений программа успешно компилируется. Это показывает, что анализ был правильным.

- **Важный урок:** Иногда для сборки старого ПО нужно не только настроить окружение, но и исправить устаревший код.


**Как это связано с LFS:**

- В процессе сборки LFS вы будете применять патчи к исходным кодам пакетов. Многие из этих патчей решают именно такие проблемы — адаптируют код к современным системам, исправляют устаревшие вызовы функций, изменяют структуры данных.

- **Примеры патчей в LFS:**

    - Исправление путей к файлам.
    
    - Замена устаревших функций на новые аналоги.
    
    - Добавление отсутствующих объявлений.
    
    - Изменение констант для совместимости с новыми версиями библиотек.

- **Навык:** Умение читать патчи (файлы `.patch`) и понимать, какие изменения они вносят, очень полезно при сборке LFS. Патч обычно показывает, какие строки нужно удалить и какие добавить.


**Практический совет перед LFS:**

1. Попробуйте собрать какую-нибудь старую программу (например, из исходников 1990-х годов). Скорее всего, вы столкнетесь с подобными проблемами.

2. Научитесь использовать утилиту `patch` для применения исправлений.

3. Попробуйте создать простой патч самостоятельно, используя `diff -u old_file.c new_file.c > my.patch`.

4. Изучите основы структур данных в C, чтобы понимать, как организованы системные вызовы и библиотеки.


**Итог этого примера:**  
Вы научились:

1. Анализировать ошибки компиляции, связанные с несоответствием структур данных.

2. Искать определения структур в системных заголовочных файлах.

3. Принимать обоснованные решения о модификации исходного кода.

4. Вносить минимальные изменения для достижения работоспособности программы.


Это высший уровень мастерства в сборке программного обеспечения: когда вы не только следуете инструкциям, но и можете исправить сам код, чтобы заставить его работать в вашей системе. Именно такие навыки позволят вам успешно собрать LFS и, что более важно, поддерживать и развивать свою систему в будущем.

**Философский итог всей книги:**  
Руководство "Building and Installing Software Packages for Linux" провело вас по всем этапам — от распаковки архива до отладки и модификации исходного кода. Вы прошли путь от пользователя, который боится исходников, до системного администратора, способного собрать, установить и исправить практически любую программу. Теперь вы готовы к LFS, где примените эти навыки в масштабе всей операционной системы. Удачи