Разработчики программного обеспечения, которые создали программное обеспечение, которое вы только что загрузили, очевидно, нуждаются в каком-то способе компиляции и установки этого программного обеспечения на своих собственных машинах. **Какие бы конфигурационные файлы ни были необходимы для инструментов, которые они используют, они почти всегда включены в архивный файл.** Поскольку разработчики открытого исходного кода хотят, чтобы как можно больше людей использовали их программное обеспечение, они также прилагают некоторые усилия, чтобы облегчить сборку и установку программного обеспечения на различных системах. Однако они не могут поддерживать все возможные конфигурации в мире.

В конечном итоге, **цель процесса установки — преобразовать исходный код в форму, которую локальный компьютер может выполнить**, а затем разместить все необходимые файлы в каталогах, которые перечислены в переменной `$PATH` для всех пользователей (чтобы они могли выполнять эти файлы). Установка модулей для интерпретируемых языков немного отличается; эти файлы устанавливаются там, где интерпретатор (например, `python` или `perl`) может их найти, а не непосредственно в `$PATH`.

[[#Configure и Make]]
[[#Другие инструменты сборки]]

---

### Configure и Make

Наиболее широко распространенным инструментом, используемым **для управления компиляцией и установкой исходного кода**, является `make`. `Make` — это приложение, которое принимает конфигурационный файл (называемый `makefile`), **содержащий список правил, большинство из которых имеют форму:**

```te xt
когда ЦЕЛЕВОЙ-ФАЙЛ старее ИСХОДНОГО-ФАЙЛА, тогда КАКОЕ-ТО-ДЕЙСТВИЕ
```

**Целевой файл** — это конечный продукт или какой-то промежуточный этап. 
**Исходный файл** — это написанный вручную исходный код или какой-то промежуточный артефакт. 

Действие обычно представляет собой **вызов компилятора, компоновщика или подобного, который воссоздает целевой файл**. Этот документ слишком краток, чтобы вдаваться в детали очень сложной и мощной команды `make`; к счастью, обычно не нужно понимать `makefile` для компиляции программного обеспечения — если только что-то не пойдет не так.

К сожалению, хотя синтаксис `makefile` очень мощный, его все же недостаточно, чтобы справиться со всеми возможными способами настройки компьютеров и всеми возможными способами, которыми человек, устанавливающий программное обеспечение, может захотеть скомпилировать приложение. Поэтому многие программные пакеты поставляются с `shell`-скриптом с именем «`configure`» и шаблоном `makefile` с именем «[Makefile.in](https://Makefile.in)». Скрипт `configure` **принимает список параметров конфигурации в командной строке и преобразует шаблон** `makefile` в реальный `makefile`, настроенный для локального компьютера и пожеланий установщика. Последовательность установки поэтому обычно выглядит так:

```bash
# распаковать и прочитать документацию
tar xf filename
cd {каталог, созданный на предыдущем шаге}
less README
less INSTALL

# сгенерировать настроенный makefile
./configure {некоторые опции ...}

# скомпилировать всё в локальном каталоге
make

# обновить глобальные каталоги
sudo make install
```

> *Кстати: скрипт «`configure`» автоматически генерируется программным обеспечением под названием `autotools`, но это не имеет значения для человека, использующего его.*

`Configure` обычно вызывается как `«./configure»`, чтобы избежать двух возможных проблем:

1. **У некоторых пользователей нет «.» в их переменной** `$PATH`. В частности, у пользователя `root` этого нет по соображениям безопасности.

2. **У некоторых пользователей «.» не является первой записью в их** `$PATH`, что означает, что может быть запущен неправильный скрипт конфигурации.

В общем, **лучше выполнять все шаги**, кроме` «make install»,` **как обычный системный пользователь, а не root**. Это позволяет избежать ошибок и, возможно, некоторых атак (хотя, поскольку шаг установки выполняется как root, это не сильно защищает). Однако установка программного обеспечения в глобальные каталоги `/bin` или `/usr` обычно требует прав администратора (если вы не используете «менеджер пакетов на основе пользователя» или подобную редкую настройку).

Некоторые проекты предоставляют `makefile`, но не скрипт `«configure»;` в этом случае шаг` «configure»` **выше можно опустить**. Либо приложение достаточно простое и не нуждается в нём, либо разработчики программного обеспечения встроили больше логики в написанный вручную `makefile`.

Не все системы настроены с включенным «`sudo`». В этом случае используйте следующее:

```bash
su  # затем необходимо ввести пароль root
make install
exit
```

Для большинства программного обеспечения команды `configure` и `make` **могут быть запущены в том же каталоге, что и исходный код,** как показано выше. **В результате новые файлы, созданные во время компиляции, смешиваются с оригиналами, что несколько беспорядочно**, но команда «`make clean`» может быть использована **для очистки позже**. Однако для некоторого программного обеспечения необходимо создать временный каталог, изменить текущий рабочий каталог на этот каталог, а затем выполнить шаги сборки там; документация проекта должна указывать, необходимо ли это. **Некоторые люди считают, что лучше всегда собирать из временного каталога.** Пример сборки с использованием отдельного каталога рядом с исходным кодом, что является распространенным соглашением:

```bash
# распаковать в каталог {имя_пакета}
tar xf filename

# создать отдельный каталог сборки
mkdir {имя_пакета}-build

# скомпилировать всё в отдельном каталоге сборки
cd {имя_пакета}-build
../{имя_пакета}/configure {некоторые опции}
make

# обновить глобальные каталоги
sudo make install
```

---

### Другие инструменты сборки

Некоторые проекты используют `cmake` **в качестве инструмента сборки**. `cmake` работает несколько похоже на `configure` (см. выше); он генерирует `makefile`, содержание которого зависит от параметров, переданных команде `cmake`, и от особенностей локальной системы. Шаги, необходимые для сборки пакета на основе `cmake`, **идентичны примерам** `«configure/make»` **выше**, за исключением того, что шаг `configure` заменяется на:

```bash
cmake . -DCMAKE_BUILD_TYPE=Release {некоторые опции ...}
```

Как всегда, проверяйте документацию проекта для получения инструкций о том, как собрать.

Некоторые проекты используют инструменты сборки на основе `python` или `perl`, а не `make`. Принципы всё ещё довольно похожи.

Программное обеспечение, которое не нужно компилировать, обычно имеет довольно простой и быстрый процесс установки. В частности, приложения, написанные на интерпретируемых языках Perl или Python, могут быть установлены просто путем копирования файлов в соответствующее место. Тем не менее, эти проекты включают программу или скрипт в архивный файл, который выполняет эту задачу, вместо того чтобы требовать от установщика делать это вручную.


---
[[Навигация по книге Beginner's Guide to Installing from Source]]

### Зачем вам это нужно?

**Структурированный подход к сборке:**

1. **Отдельный каталог сборки:** Современная лучшая практика — собирать в отдельном каталоге (`{package}-build`). Это сохраняет исходники чистыми.

2. **Безопасность:** Работа от обычного пользователя до `make install` — важное правило безопасности.

3. **CMake:** Появился новый стандарт системы сборки. Многие современные проекты используют `CMake` вместо `autotools`.

4. **Интерпретируемые языки:** Python/Perl пакеты устанавливаются иначе — через их собственные системы пакетов (`pip`, `cpan`).


**Для LFS:** Большинство пакетов в LFS используют `autotools` (`configure`/`make`), но некоторые используют `CMake`. Вы познакомитесь с разными системами сборки.

