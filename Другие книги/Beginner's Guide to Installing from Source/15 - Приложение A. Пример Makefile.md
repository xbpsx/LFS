**К сожалению, при сборке пакетов из исходного кода нередко возникают ошибки компиляции.** Иногда возможно диагностировать и исправить проблему, изучив `makefile`, т.е. базовое понимание синтаксиса `makefile` может быть полезным. Вот очень краткий пример базового синтаксиса и функциональности; для получения дополнительных подробностей см. документацию make или одно из многих руководств, доступных в Интернете.

Пример `makefile` для сборки исполняемого файла с именем «`prog`», который имеет один исходный файл «`c`», один заголовочный файл и использует одну библиотеку (которую он также собирает из одного исходного файла «`c`»), может выглядеть следующим образом:

```makefile
prog: prog.c prog.h libmylib.a
  gcc -o prog prog.c -L. -lmylib

libmylib.a: libmylib.o
  ar -rcs libmylib.a libmylib.o

libmylib.o: libmylib.c libmylib.h
  gcc -c -o libmylib.o libmylib.c
```

Форма записей (правил):

```makefile
цель: зависимость1 [зависимость-n ...]
<табуляция> команда для выполнения
...
```

Для каждого «правила», если цель отсутствует или старше любой из зависимостей (на основе временных меток файлов), то команда(ы) выполняются для (пере)создания цели. Однако каждая зависимость сначала проверяется, есть ли правило, у которого она является целью. Если да, то эта цель рекурсивно оценивается, т.е. (пере)собирается, если она отсутствует или старше своих зависимостей.

> Таким образом, в приведённом выше наборе правил изменение в` libmylib.c` приведет к пересборке `libmylib.o.` Затем `libmylib.a `пересоздаётся и, наконец, `prog` пересобирается.

`Makefile` могут становиться очень сложными, и многие из них генерируются автоматически, но приведённые выше принципы всегда применяются.

---
[[Навигация по книге Beginner's Guide to Installing from Source]]

### Зачем вам это нужно?

**Понимание Makefile:**

- Этот простой пример показывает, как работает система зависимостей в make.

- **Для LFS:** Хотя вы редко будете редактировать Makefile вручную, понимание их структуры поможет в отладке.